---
title: "ST558_Project 1"
authors: "Lamia Benyaine & Scott Van Slyck"
description: "Write functions to manipulate a process data sets"
date: "June 18, 2024"
format: html
editor: visual
---

# *Data Processing*

These are the libraries needed for this program.

```{r libraries}
library(readr)
library(dplyr)
library(tidyr)
library(lubridate)
library(ggplot2)
```

Create a function to read in a csv from a url.
```{r read csv}
read_csv_code <- function(url) {
  data = read_delim(url, delim = ",")
  return(data)
}
```

Write a function that does steps 1 and 2 to select certain columns and convert the data into long format so area_name only has one enrollment value.

```{r function for steps 1 & 2}
function_step_1_2 <- function(data, pivot = "enrollment") {
  return_1 <- 
  data |>
  as_tibble() |>
  rename(area_name = Area_name) |>
  select(area_name, STCOU, ends_with("D")) |>
  pivot_longer(cols = 3:12,
               names_to = "attribute", 
               values_to = pivot)
  return(return_1)
}
```

Write a function that takes in the previous function and converts the pivoted column into a year and a measurement column.

```{r function for step 3}
function_step_3 <- function(data) {
  return_2 <- 
    data |>
    mutate(year = year(parse_date_time(substr(data$attribute, 8,9), "y")),
           measurement = substr(data$attribute, 1,7))
  return(return_2)
}
```

Write a function for step 5, to create a new variable for state in the county tibble.

```{r function for step 5}
function_step_5 <- function(data) {
  return_3 <-
    data |>
    mutate(state = substr(data$area_name, nchar(data$area_name)-1, nchar(data$area_name)))
  return(return_3)
}
```

Write a function for step 6, to create a new variable for division in non-county level tibble.

```{r function for step 6}
function_step_6 <- function(data) {
  #Create vectors to assign the states based on the Census designated divisions
  div1 <- c("CONNECTICUT", "MAINE", "MASSACHUSETTS", "NEW HAMPSHIRE", "RHODE ISLAND", "VERMONT")
  div2 <- c("NEW JERSEY", "NEW YORK", "PENNSYLVANIA")
  div3 <- c("ILLINOIS", "INDIANA", "MICHIGAN", "OHIO", "WISCONSIN")
  div4 <- c("IOWA", "KANSAS", "MINNESOTA", "MISSOURI", "NEBRASKA", "NORTH DAKOTA", "SOUTH DAKOTA")
  div5 <- c("DELAWARE", "FLORIDA", "GEORGIA", "MARYLAND", "NORTH CAROLINA", "SOUTH CAROLINA", "VIRGINIA", "WASHINGTON", "DISTRICT OF COLUMBIA", "District of Columbia", "WEST VIRGINIA")
  div6 <- c("ALABAMA", "KENTUCKY", "MISSISSIPPI", "TENNESSEE")
  div7 <- c("ARKANSAS", "LOUISIANA", "OKLAHOMA", "TEXAS")
  div8 <- c("ARIZONA", "COLORADO", "IDAHO", "MONTANA", "NEVADA", "NEW MEXICO", "UTAH", "WYOMING")
  div9 <- c("ALASKA", "CALIFORNIA", "HAWAII", "OREGON", "WASHINGTON")

  #Use conditions to assign the division name
  return_4 <- 
    data |>
    mutate(division = if_else(data$area_name %in% div1, "New England", 
                           if_else(data$area_name %in% div2, "Middle Atlantic", if_else(data$area_name %in% div3, "East North Central", if_else(data$area_name %in% div4, "West North Central", if_else(data$area_name %in% div5, "South Atlantic", if_else(data$area_name %in% div6, "East South Central", if_else(data$area_name %in% div7, "West South Central", if_else(data$area_name %in% div8, "Mountain", if_else(data$area_name %in% div9, "Pacific", "ERROR" ))))))))))
  return(return_4)
}
```

Write another function that takes in the output from step 3 and creates the two tibbles in step 4, calls the above two functions (to perform steps 5 and 6), and returns two final tibbles.

```{r function for steps 4, 5, and 6}
function_steps_4_5_6 <- function(data) {
  #Step 4
  #Find all the indices where the area name contains a county
  county_index <- grep(pattern = ", \\w\\w", data$area_name)
  
  #Create an index column
  data$index <- c(1:nrow(data))
  
  #Subset the data into two tibbles
  county_tb <- data |>
    filter(index %in% county_index) |>
    select(-index)
  
  state_tb <- data |>
    filter(! index %in% county_index) |>
    select(-index)
  
  #Change the class of both tibbles
  class(county_tb) <- c("county", class(county_tb))
  class(state_tb) <- c("state", class(state_tb))
  
  #Step 5 function
  county_tb <- function_step_5(county_tb)
  
  #Step 6 function
  state_tb <- function_step_6(state_tb)
  
  return_list <- list(county_tb, state_tb)
 return(return_list)
}
```

Create a wrapper function that takes in the URL of a .csv file format and the optional argument for the variable name, combines all the above functions and returns two tibbles.

```{r wrapper function}
proccessing_wrapper <- function(url, pivot = "enrollment") {
  result <- 
    read_csv_code(url) |>
    function_step_1_2(pivot) |>
    function_step_3() |>
    function_steps_4_5_6()
  return(result)
}
```


# *Data Combining*

Combines two datasets and separates them by county and non-county data and returns a list of the two.

```{r}
combine_datasets = function(data1, data2){
  # function for identifying county-level data
  is_county_level = function(data){
    if ("STCOU" %in% colnames(data)){
    return(!grepl("000$", data$STCOU))
  }
  return(FALSE)
  }
  
  # separating data by county/non-county for both datasets
  county_data1 = data1 |> filter(is_county_level(data1))
  non_cty_data1 = data1 |> filter(!is_county_level(data1))
  
  county_data2 = data2 |> filter(is_county_level(data2))
  non_cty_data2 = data2 |> filter(!is_county_level(data2))
  
  # combine data
  combo_county = dplyr::bind_rows(county_data1, county_data2)
  combo_non_cty = dplyr::bind_rows(non_cty_data1, non_cty_data2)
  
  return(list(county_data = combo_county, non_county_data = combo_non_cty))
}
```

<<<<<<< HEAD
# *EDU01 Dataset run*
=======
# *Generic Summarize Functions*

## Plot State Function

Write a function that plots the mean value of the variable selected, across the years, and for each division. Also, removed observations at the ERROR setting of Division.

```{r plot state data}
plot.state <- function(data, var_name = "enrollment") {
 plot_state_data <-
   data |>
   group_by(division, year) |>
   filter(division != "ERROR") |>
   mutate(mean = mean(get(var_name)))
 
 #create a line plot
 ggplot(data = plot_state_data, aes(x = year, y = mean, group = division)) +
   geom_line(aes(color = division)) +
   geom_point(aes(color = division)) +
   ggtitle(cat(eval(var_name), "means plot by division"))
}
```

## Plot County Function
```{r}
plot.county = function(data, var_name = "enrollment", state = "fix", top_bottom = "top", num_counties = 5){
  # Filtering the data by state, need to fix
  data_state = data |> filter(State == state)
  
  # overall mean of the statistic
  mean_value = data_state |>
    group_by(area_name) |>
    summarize(mean_stat = mean(get(var_name), na.rm = TRUE))
  
  # filtering the data based on top_bottom
  if (top_bottom == "top"){
    top_areas = mean_value |> arrange(desc(mean_stat)) |> slice_head(n = num_counties)
  } else{
    top_areas = mean_value |> arrange(mean_stat) |> slice_head(n = num_counties)
  }
  
  data_filter = data_state |> filter(area_name %in% top_areas$area_name)
  
  # plotting
  ggplot(data_filter, aes(x = year, y = get(var_name), color = area_name)) +
    geom_line() + 
    labs(title = paste("Statistic", var_name, "Across years by area_name"), x = "Year", y = var_name) + 
    theme_minimal()
}
```

# *Putting it all together*

## EDU01 Data set run

## PST01 Dataset run


>>>>>>> 46f6eeb8b21ce89cf4aeb4b86702828f66641aba

